<html>
<head>
<meta charset="UTF-8">
<title>
HMS Pathways Compass
</title>
<link rel="stylesheet" href="./resources/css/bootstrap.min.css">
<link rel="stylesheet" href="./resources/css/bootstrap-theme.min.css">
<link rel="stylesheet" href="./resources/css/font-awesome.min.css">
<link rel="stylesheet" href="./resources/css/compass-extras.css">
<script src="./resources/js/lodash.min.js"></script>
<script src="./resources/js/jquery-2.1.4.js"></script>
<script src="./resources/js/bootstrap.min.js"></script>
<script src="./directory.js"></script>
<script src="./invertedIndex.js"></script>
</head>
<body>

<div class="container">
  <!-- Title Bar -->
  <div class="row">
    <div class="page-header col-lg-12">
      <h1>Pathways MedEd Compass <small><i> for the wards and beyond!</i></h1>  
      <h5 style="color:gray;margin-top:20px;">#ProTip: Separate phrases by commas to find documents with all of these phrases</h5>
    </div>
  </div>

  <!-- Search Bar-->

  <div class="row"> 
    <div class="col-xs-12">
      <input id="search" style="display: inline-block; width: calc(100% - 120px); margin-right: 10px;" type="text" class="form-control" placeholder="ex: Cancer, Immunotherapy"/>
      <!-- FIXME We have to click twice the first time we want to hide the filtering list -->
      <button class="btn btn-sm" id="filter-toggle">
      <i class="fa fa-minus-circle"></i> Toggle filters</button>
    </div>
  </div>

  <div id="filter-holder" class=".collapse">
  </div>


  <!-- Results Are Put Here -->
  <div id="results" style="margin-top: 10px;">
  </div>
</div>

<script>

// Config
var delay = 300; // ms to wait before searching
var maxSnippets = 5; // max # of snippets to show below
var maxResults = 100; // max results to show
var mapPrefix = '__prefix__';

var results;
var cachedResultsByTopic = {};
var topicPreferences = localStorage.getItem('prefs') ? JSON.parse(localStorage.getItem('prefs')) : {};
var lastClick = new Date();
var timeout;



$(document).ready(function() {
    
  $('.btn').button();
  $('#search').on('input', inputChange);
  $('#filter-toggle').click(function() {
    $('#filter-toggle i').attr('class', 
      $('#filter-holder').is(':visible') ? 
      'fa fa-plus-circle' : 
      'fa fa-minus-circle')
    $('#filter-holder').slideToggle();
    // if ($('#filter-holder').is(':visible'))
  });


  inputChange();

  function toggleTopicButtion(e) {
    console.log(e.target.name);
    topicPreferences[e.target.name] = e.target.checked;
    localStorage.setItem('prefs', JSON.stringify(topicPreferences))
    makeResultHTMLElements(results);
    // refilterSearchResults();
  }

  // function refilterSearchResults() {
  //   console.log('would refilter here for');
  //   makeResultHTMLElements(results)
  // }
  
  function inputChange() {
    query = $('#search').val();
    $('#results').empty();
    $('#results').append($(
      '<h5> Searching... </h5>'));

    $('#filter-holder').empty();

    lastClick = new Date();
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      
      
      results = getSearchResults(query);
      console.log('Search Results for', query, results.slice(0, 100), results.length);

      // Get topics
      _.forEach(results, function(result) {
        if (result.topic != null) {
          if (cachedResultsByTopic[result.topic] == null) {
            cachedResultsByTopic[result.topic] = [];
          }
          cachedResultsByTopic[result.topic].push(result);
        }
      });

      makeResultHTMLElements(results);
      // TODO FIXME Boxes shouldn't be visible initially

      $('#filter-holder').empty();  // TODO save users preferences re: toggle state before emptying
      $('#filter-holder').off('change');

      makeTopicCheckboxHTMLElements();

      if (results.length == 0 && query.length != 0) {
        $('#results').append($(
        '<div class="panel panel-default">' +
        ' <div class="panel-body">' +
        '   <h5> No Results. Typo? </h5>' +
        ' </div>' +
        '</div>'));
      }

      
    }, delay);
  };

  function makeTopicCheckboxHTMLElements() {

    // Use lodash to ensure stable sorting. Both inner arguments are globals
    // var topicArray = _.sortBy(_extractLocalProperties(mapPrefix, cachedResultsByTopic));
    var topicArray = _.sortBy(Object.keys(cachedResultsByTopic));

    var checkboxHTMLElements = [];
    var newButtons = '<div class="filter-button-array">' +
      '<div class="btn-group btn-group btn-group-justified" style="display: inline-block; width: 100%;" data-toggle="buttons">';
    
    for (var i = 0; i < topicArray.length; i ++) { // Only display four items per line

      // var arrayLimit = Math.min(i + 4, topicArray.length);
      // for (var j = i; j < arrayLimit; j++) {
        var collapsedTopic = topicArray[i].split(/\s+/).join('');

        if (topicPreferences[collapsedTopic] != null) {
          checked = topicPreferences[collapsedTopic];
        } else {
          checked = true;
        }

        newButtons += '' +
            '<label class="btn active" id="' + collapsedTopic +'" style="display: inline-table;">' +
              '<input type="checkbox" name="' + collapsedTopic + '" ' + (checked ? 'checked' : '') +'>' +
                '<i class="fa fa-square-o fa-2x"></i><i class="fa fa-check-square-o fa-2x"></i>' + 
                '<span class="topic-text">  ' + topicArray[i] + '</span>' +
            '</label>';
        // Binding click events to #filter-holder, which currently exists. The 
        // buttons have not been added to the DOM
        $('#filter-holder').on('change', '#' + collapsedTopic, toggleTopicButtion);
    }
    newButtons += '</div></div>';
    console.log(newButtons);
    $('#filter-holder').append($(newButtons));
    
  }

  function filterByTopic(result) {
    var collapsedTopic = result.topic != null ? result.topic.split(/\s+/).join('') : null;
    if (topicPreferences[collapsedTopic] != null) {
      return topicPreferences[collapsedTopic];
    } else {
      return true;
    }
  }

  function makeResultHTMLElements(resultsData) {
    /*
     * Given a result object, return a jQuery element of the
     * appropriate `div`. Also, populate `cachedResultsByTopic`, a map of 
     * topic - array of related results
     */
    var resultElements = [];
    _.filter(resultsData, filterByTopic).slice(0, maxResults).forEach(function(r) {

      var newResult = '<div class="panel panel-default">' + ' <div class="panel-body">'
      if (r.local) {

        var pdfFileLink = './content/' + r.link;
        newResult += '    <h5><a href="' + pdfFileLink + '" target="_blank">'+r.link+'</a></h5>' +
          '<p>    Snippets (click a snippet to access document):<p><ul>';

        if (r.snippets) {
          for (var i = 0; i < r.snippets.length; i++) {
            // Example `n`: {text: 'Here is a query with context.', pageNo: 5}
            newResult += (
            '<li> <a class="snippet" href="' + pdfFileLink + '#page=' + r.snippets[i].pageNo + '" target="_blank">' +
              r.snippets[i].text +
            '</a></li><br>' // should eventually style this and add padding-bottom
            );
          }
        }
        newResult +=  '</ul>  </div></div>';

      } else {
        newResult += '    <h5>' + '<a href="'+r.link+'" target="_blank">'+r.title+'</a>' +'</h5>' +
          '   Link to '+r.link+'<br>';
      }
      resultElements.push($(newResult));
    });
    // return resultElements;

    $('#results').empty();
    $('#results').append(resultElements);
  }

  function invIndexSearch(directory, queryArray) {

    var titleWeight = 1000;  // Value title matches 1000x body matches

    // Currently, the inverse index isn't set up to handle
    // bigrams. Will have a second query array as a workaround
    var queryUnigrams = [];
    for (var i = 0; i < queryArray.length; i++) {
      // Need Array.push to update queryUnigrams in place
      Array.prototype.push.apply(queryUnigrams, queryArray[i].split(/\s+/));
    }

    var titleMatches = getTitleMatch(directory, queryUnigrams);
    var bodyMatches = getBodyMatch(invertedIndex, queryUnigrams);

    var tempMatchedDocumentArray = titleMatches.concat(bodyMatches);
    var matchedDocuments = {};
    for (var i = 0; i < tempMatchedDocumentArray.length; i++) {
      matchedDocuments[mapPrefix + tempMatchedDocumentArray[i]] = 1;
    }
    var matchedDocumentsArray = _extractLocalProperties(mapPrefix, matchedDocuments);

    var hitsPerFile = null;
    if (titleMatches.length || matchedDocumentsArray.length) {
      hitsPerFile = getHitsPerFile(queryUnigrams, invertedIndex, matchedDocumentsArray);
    }

    var results = [];
    _.forEach(_.pick(directory, matchedDocumentsArray), 
              function(content, title) {
      // sort by title matches first, then the num of snippets. Can use a big number to weight title matching.
      var noBreaks = content.text.split('\n').join(' ');

      // May not be important to determine the precise number of hits per title;
      // it's not clear that having >1 title hit makes a document more pertinent
      var titleMatches = getMatches(title.split('_').join(' '), queryArray);
      var bodySnippets = getSnippets(noBreaks, queryArray);

      // Calculate number of hits per file
      var bodyMatchNum = 0;
      for (var i = 0; i < queryUnigrams.length; i++) {
        // This introduces something of a bug - we double count `renal` and `cell`
        // if a user enters "renal cell"
        bodyMatchNum += hitsPerFile[title][queryArray[i]];
      }

      if (bodySnippets != null || (titleMatches.length > 0 && content.text == '')) {
        var result = {
          title: title,
          snippets: bodySnippets,
          topic: content.localPath != null ? content.localPath.match(/^([^/]+).*/)[1] : null,

          link: content.localPath || content.webPath,
          local: content.localPath != null,

          titleMatches: titleMatches.length,
          bodyMatchNum: bodyMatchNum,
          // Lower is better
          score: -(titleMatches.length * titleWeight + bodyMatchNum),
        };

        results.push(result);
      }
    });
    return results;
  }

  function getTitleMatch(directory, queryArray) {
    // queries - array of comma-delimited queries

    // Loop through filenames (keys) of directory.js to find matching titles
    //
    // In this case, we don't really care if there are multiple matches, since
    // a title that repeats a query twice isn't obviously more interesting
    // than a title that only has one instance of a query.
    var matchingDocuments = [];
    for (var i = 0; i < queryArray.length; i++) {
      for (var documentTitle in directory) {
        if (documentTitle.toLowerCase().indexOf(queryArray[i]) >= 0) {
          matchingDocuments.push(documentTitle);
        }
      }
    }
    return matchingDocuments;
  }

  function getBodyMatch(invertedIndex, queryArray) {
    // Return names of documents containing any whole string found
    // in queryArray

    var tempMatchedDocuments = {}; // 'set' of matched documents
    for (var i = 0; i < queryArray.length; i++) {

      var docList = invertedIndex[queryArray[i]];
      if (typeof docList === 'undefined') {
        continue;
      }
      for (var j = 0; j < docList.length; j++) {
        tempMatchedDocuments[mapPrefix + docList[j].file] = 1;
      }
    }
    return _extractLocalProperties(mapPrefix, tempMatchedDocuments);
  }

  function getHitsPerFile(queryArray, invertedIndex, matchedDocuments) {
    // Return a map of filename to {query: queryFrequency} objects
    
    resultsMap = {};
    for (var i = 0; i < matchedDocuments.length; i++) {
      resultsMap[matchedDocuments[i]] = {};
    }

    for (var i = 0; i < queryArray.length; i++) {
      var q = queryArray[i];
      var allQueryContainingDocs = invertedIndex[q];
      if (typeof allQueryContainingDocs === 'undefined') {
        continue;
      }

      for (var j = 0; j < allQueryContainingDocs.length; j++) {
        var f = allQueryContainingDocs[j].file;
        if (f in resultsMap) {
          resultsMap[f][q] = allQueryContainingDocs[j].freq;
        }
      }
    }
    return resultsMap;
  }

  function _extractLocalProperties(prefix, o) {
    // Return an array of properties in `o` that
    // begin with `prefix`
    var properties = [];
    for (var k in o) {
      if (k.startsWith(prefix)) {
        properties.push(k.slice(prefix.length, k.length));
      }
    }
    return properties
  }

  function getSearchResults(query) {
    // Split up query by commas
    var splitQuery = query.toLowerCase().split(',');
    splitQuery = _.filter(splitQuery, function(n) {
      return n.split(' ').join('').length > 1;
    });

    // `directory` obtained from global scope
    return invIndexSearch(directory, splitQuery);
  };

  // Gets a list of text matches for a given document. Only
  // used to look for title matches
  function getMatches(text, queries) {
    var allMatches = [];

    var nextIndexes = {};
    queries.forEach(function (q, i) {
      nextIndexes[q] = text.toLowerCase().indexOf(q, (nextIndexes[q] != null ? nextIndexes[q] + 1 : 0));
    });
    var closest = _.sortBy(
        _.filter(
          _.pairs(nextIndexes), function (n) { return n[1] >= 0;}), 
        function(n) { return n[1];}
        )[0];

    // XXX Unnecessary, as this fxn only is used to search titles (which will rarely have multiple
    // instances of an interesting query
    while (closest != null) {
      allMatches.push(closest);
      queries.forEach(function (q, i) {
        nextIndexes[q] = text.toLowerCase().indexOf(q, (nextIndexes[q] != null ? nextIndexes[q] + 1 : 0));
      });
      closest = _.sortBy(_.filter(_.pairs(nextIndexes), function (n) { return n[1] >= 0;}), function(n) { return n[1];})[0];
    }
    return allMatches;
  };

  // Generates bolded snippets by searching the content's body
  function getSnippets(text, queries) {
    // text - content from a PDF
    // queries - list of queries inserted into search box

    var containsAllParts = true;
    queries.forEach(function(n) {
      if (text.toLowerCase().indexOf(n) == -1) {
        containsAllParts = false;
      }
    });

    if (!containsAllParts) {
      return;  // not all query parts match in the text.
    }   

    var nextIndexes = {};
    var snippetTextArray = [];
    var snippets = [];

    var first = true;
    var queryContextLength = 1000; // Chars to return around query
    var lastSnippetPage = 1;
    var closest;
    var lastClosest = [null, {index:0, query:null}];

    var lowerCaseText = text.toLowerCase()
    // Run through text looking for instances of either query. Make a snippet of the
    // closest result. Reset results after each loop (this may discount cases where the
    // second query occurs just after the first query, but isn't an important bug)
    while ((closest != null && snippets.length < maxSnippets) || first) {

      queries.forEach(function (q, i) {
        nextIndexes[q] = {
          // Start from the previous search's index. Record the index of any new match
          index: lowerCaseText.indexOf(q, (nextIndexes[q] != null ? nextIndexes[q].index + 1 : lastClosest[1].index)),
          query: q
        };
      });
      // Of the queries were there was a match, we consider the match with the lowest index. The
      // innermost function unrolls the map, saving us from having to specify its keys
      closest = _.sortBy(_.filter(_.pairs(nextIndexes), function (n) { return n[1].index >= lastClosest[1].index;}), 'index')[0];

      if (closest != null) {
        // Logic: consider the case where multiple snippets are taken from the same page, say page 2. No
        // form feed characters will intercede, but ''.split('\f').length is 1. Thus, we decrement
        // the result of the above function call by 1.
        var snippetPage = lastSnippetPage + lowerCaseText.slice(lastClosest[1].index, closest[1].index).split('\f').length - 1;
        var lastSnippetPage = snippetPage;
        lastClosest = closest;

        // We don't want to search all the way back to index 0 if we can avoid it (most of the
        // time, we expect there to be a lot of text between index 0 and closest.index.
        //
        // We try to get away with just looking at the last `queryContextLength` characters
        var beforeIndex = (closest[1].index - queryContextLength) < 0 ? 0 : (closest[1].index - queryContextLength);
        var before = text.substring(beforeIndex, closest[1].index).match(/[^\.\-\–\?]*$/)[0];

        var afterIndex = ((closest[1].index + closest[1].query.length + queryContextLength) > text.length) 
          ? text.length 
          : (closest[1].index + closest[1].query.length + queryContextLength);
        var after = text.substring(closest[1].index + closest[1].query.length, afterIndex).match(/.[^\.\-\–\?]+/)[0];

        var newSnippet = before + '<b>' + closest[1].query + '</b>' + after + '. <i>(Page ' + snippetPage + ')</i>';
        // NOTE Only showing one result per page (if a user is interested, s/he will likely
        // already know from the first snippet shown.
        if (snippetTextArray.indexOf('Page ' + snippetPage) == -1) {
          snippetTextArray.push('Page ' + snippetPage);
          snippets.push({'text': newSnippet, 'pageNo': snippetPage});
        }
      }

      first = false;
    }

    return snippets.length > 0 ? snippets : null;   
  }


});


</script>
</body>
</html>
